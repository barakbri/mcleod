% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mcleod_main_function.R
\name{mcleod.covariates.estimation.parameters}
\alias{mcleod.covariates.estimation.parameters}
\title{Creates object defining computational and statistical parameters, when estimating a random effect model with covariates.}
\usage{
mcleod.covariates.estimation.parameters(
  proposal_sd = c(0.05),
  beta_prior_sd = c(1),
  beta_init = NULL,
  Manual_Prior_Values = NULL,
  Manual_Prior_Probs = NULL,
  do_P_k_i_hashing = F,
  P_k_i_hashing_resolution_by_theta = 1e-04
)
}
\arguments{
\item{proposal_sd}{vector of standard deviations for the proposal distribution, for the values of beta. Proposals are generated by adding a random value from N(0,diag(proposal_sd)) to the current MCMC value of beta.}

\item{beta_prior_sd}{vector of standard deviations for the prior. The prior for beta is assumed to be N(0,diag(beta_prior_sd)). Setting an entry to a negative value (e.g. -1) will use an uninformative prior (constant) for that component of beta.}

\item{beta_init}{Initial values for \eqn{\vec{\beta}} in the MCMC sampler. If set to \code{NULL}, will use a normal random intercept regression for initial estimate.}

\item{Manual_Prior_Values}{When using a predefined prior for beta, a vector of sorted values defining the paritioning points for a piece-wise constant prior for beta.}

\item{Manual_Prior_Probs}{A matrix with number of rows equal to = length(Manual_Prior_Values)-1, and number of columns equal to the number of covariates, giving the probablities for the different segments defined by  \code{Manual_Prior_Values}. Within each segment, it is assumed the prior is uniformly distributed.}

\item{do_P_k_i_hashing}{A computational workaround for faster computation of bayesian probabilites. See additional details in the appendix describing the computational method, in the dissertation of Brill (2022)}

\item{P_k_i_hashing_resolution_by_theta}{Resolution parameter for the computational workaround activated by do_P_k_i_hashing}
}
\value{
an object of type 'mcleod.covariates.estimation.parameters.obj'
}
\description{
For binomial response, the model with covariates is \eqn{log(P_i/(1-P_i)) = \gamma_i + \vec{\beta}^T \vec{Z}_i}, where the density of \eqn{\gamma_i}'s is estimated from the data, \eqn{\vec{\beta}} is a vector of slopes, and \eqn{\vec{Z}_i} is a vector of covariates. For Poisson errors, the model equation is \eqn{log(\lambda_i) = \gamma_i + \vec{\beta}^T \vec{Z}_i}. The function is used to create an object the defines the prior distribution of \eqn{\vec{\beta}}, as well as the proposal distribution used for drawing new values of \eqn{\vec{\beta}} in the MCMC algorithm.
}
\details{
The default prior assumed for \eqn{\vec{\beta}} is a multivariate normal prior, with mean of 0, and a covariance matrix given by \code{diag(beta_prior_sd)}. Setting one of the standard deviations to a negative value means a non-informative prior is assumed for the slope coefficient.

Alternatively, the user may define a non normal prior for each slope coefficient. This is done by supplying the the function with a series piece-wise constant density functions serving as priors for the different slope coefficients.
A piecewise constant prior density function with M segments has M+1 partitioning points. These are supplied using the argument \code{Manual_Prior_Values}. The density values for each segment are given by \code{Manual_Prior_Probs}, which has M rows (one for each segment), and number of columns equal to the number of covariates.
The parameter \code{beta_init} sets the initial values for \eqn{\vec{\beta}} in the MCMC sampler. The default value is \code{NULL}, meaning a normal random intercept regression will be used to guess an initial estimate. The type of regression used is either Binomial or Poisson, depending on the sampling distribution defined when calling \code{\link{mcleod}}.
}
\examples{
 # For full description of package model and workflow,
 # including this function, Type browseVignettes(package = 'mcleod') 
 # in the R console and check the package vignette

library(mcleod)
#############################
# Example 1: Binomial regression with a random normal intercept
# Example shows how to change the Standard deviation for  
# for the prior and the proposal distributions
#############################
N = 30 # Number of draws per sample
K = 300 #Number of samples
set.seed(2)
covariates = matrix(rexp(K),nrow = K) # exponentially distributed coefficients
real_beta = -0.5 #the real value of the coefficient
 
u = sample(c(0,1),size = K,replace = T)
x = rbinom(K,size = N,
         prob =inv.log.odds(rnorm(K,-1+3*u,sd = 0.3) +
                              real_beta*covariates))
n = rep(N,K)

hist(x,main ='Dist. of Xi across samples',breaks = 30)

#Generate object with parameters for covariate estimation
coeffs_obj  = mcleod.covariates.estimation.parameters(
                beta_prior_sd = 1.5,
                proposal_sd = 0.025)


comp_params = mcleod.computational.parameters(nr.gibbs = 3000)
# In addition to covariates, pass coeffs_obj as an argument 
res = mcleod(x,
             n,
             covariates = covariates,
             covariates_estimation_parameters = coeffs_obj,
             computational_parameters = comp_params
             )

#############################
# Example 2: Specifying non-normal prior for \vec{\beta}
#############################
# In this example, we have a bivariate vector of covariates, and
# specify a cauchy prior for \vec{\beta}

# Generate data:

N = 30 #nr draws per sample
K = 200 #nr samples
set.seed(1)
covariates = matrix(rnorm(K*2,sd = 0.5),nrow = K) #generate covariates
real_beta_1 = -1 #true values for slopes
real_beta_2 = 1
#generate data:
x = rbinom(K,size = N,prob = inv.log.odds(rnorm(K,0,sd = 1)
          + real_beta_1*covariates[,1] + real_beta_2*covariates[,2]))
n = rep(N,K)

# We proceed to generete a discetized representation of the prior
# we descretize the range (-5,5)
beta_prior_points = seq(-5,5,0.01)

# for each segment, we compute the probability for the slope to be in the segment
beta_prior_probs = pcauchy(beta_prior_points[-1]) - 
                  pcauchy(beta_prior_points[-length(beta_prior_points)])

# we renormalize, since we cropped the support to be (-5,5)
beta_prior_probs = beta_prior_probs/ sum(beta_prior_probs)

# plot the prior
plot(beta_prior_points[-1],beta_prior_probs,
      type = 'l',xlab = 'theta',
      ylab = 'probability in bin of beta_prior_probs')

# since we have two covariates, we duplicate the prior 
# across two columns. Generally we can have different priors
# for different components of \vec{\beta}
beta_prior_probs = matrix(c(beta_prior_probs, beta_prior_probs),ncol = 2)

#generate prior definitions' object with the new prior dist.:
coeffs_obj = mcleod.covariates.estimation.parameters(
      Manual_Prior_Values = beta_prior_points,
      Manual_Prior_Probs = beta_prior_probs)

#fit model and get results:
res = mcleod(x, n, covariates = covariates,
               covariates_estimation_parameters = coeffs_obj)

coeffs = mcleod::results.covariate.coefficients.posterior(res,plot.posterior = F)
coeffs$posterior.means
}
