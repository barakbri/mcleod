% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mcleod_main_function.R
\name{mcleod.get.posterior.mixing.dist}
\alias{mcleod.get.posterior.mixing.dist}
\title{Retrieve the estimated posterior mixing distribution, both density and CDF}
\usage{
mcleod.get.posterior.mixing.dist(
  res,
  aggregate_by = mean,
  specific_iter = NULL
)
}
\arguments{
\item{res}{object resulting from function \code{\link{mcleod}}}

\item{aggregate_by}{function to aggregate by, such as \code{\link{mean}} or \code{\link{median}} (used for computing the posterior mean / median, respectively, at each point of the support of the mixing distribution). May also be a user supplied function.}

\item{specific_iter}{Default value is \code{NULL}, meaning the function returns estimates obtained via posterior mean/ median across all gibbs samples. If the user picks a single number, this iteration of the gibbs sample is returned.}
}
\value{
A list with the following fields:
\itemize{
\item{CDF}{ - if \code{specific_iter} is set to \code{NULL}, returns an \code{R} \code{\link{approxfun}} function, giving an estimate (pointwise posterior mean/median) of the CDF of the mixing distribution. If a specific iteration is requested, will return the CDF for mixing distribution, found in the \code{specific_iter} iteration of the MCMC sampler.}
\item{density}{ - if \code{specific_iter} is set to \code{NULL}, returns an \code{R} \code{\link{approxfun}} function, giving an estimate (pointwise posterior mean/median) of the density of the mixing distribution. If a specific iteration is requested, will return the density for mixing distribution, found in the \code{specific_iter} iteration of the MCMC sampler.}
\item{a.vec}{ - Parameter vector \eqn{\vec{a}}, used to define the support of the piece-wise constant mixing distribution. See full definition in the package vignette.}
\item{pi_smp}{ - Parameter vector \eqn{\vec{\pi}}, detailing the estiamted probability mass in each segment of \eqn{\vec{a}}. Computed via pointwise posterior mean/median across MCMC samples. See full definition in the package vignette. If a specific iteration is requested, will return the value of \eqn{\vec{\pi}} sampled in that specific iteration.}
}
}
\description{
The function computes the point-wise posterior mean/median of the mixing distribution, using the MCMC samples computed by \code{\link{mcleod}}. The user may also ask for the mixing distribution (CDF,density and \eqn{\vec{\pi}}) from a specific iteration of the Gibbs sampler.
}
\details{
Posterior mean/ median computed in a pointwise manner, across points of the support, in order to obtain an estimate of the mixing distribution (which is a function). Burn-in samples (specified by the function \code{\link{mcleod}}) are removed from the MCMC samples when computing estiamtes.
}
\examples{
 # For full description of package model and workflow,
 # including this function, Type browseVignettes(package = 'mcleod') 
 # in the R console and check the package vignette

library(mcleod)
##################################
# Example 1: Binomial sampling distribution, default parameters:
# The function plots the posterior mixing distribution
##################################
N = 30
K = 300
set.seed(1)
u = sample(c(0,1),size = K,replace = T)
x = rbinom(K,size = N,prob =inv.log.odds(rnorm(K,-1+3*u,sd = 0.3)))
n = rep(N,K)

#fit model
res = mcleod(x, n)

#plot posterior mixing distribution:
posterior_mixing_dist = mcleod.get.posterior.mixing.dist(res)

#' x_points = seq(-5,5,0.01)
plot(x_points, posterior_mixing_dist$density(x_points),
type = 'l',xlab = 'theta',ylab = 'Density')

x_points = seq(-5,5,0.01)
plot(x_points, posterior_mixing_dist$CDF(x_points),
type = 'l',xlab = 'theta',ylab = 'Density')

#############################
# Example 2: Binomial regression with a random normal intercept
#############################
# Generate data:
N = 30 #Number of draws per binomial observations
K = 200 #Number of samples
set.seed(1)
covariates = matrix(rnorm(K*2,sd = 0.5),nrow = K) #Generate covariates
colnames(covariates) = c('covariate 1','covariate 2')
#define slopes:
real_beta_1 = -1
real_beta_2 = 1
#sample
x = rbinom(K,size = N,
prob = inv.log.odds(rcauchy(K,location = 0,scale = 0.5) +
real_beta_1*covariates[,1] + real_beta_2*covariates[,2]))
n = rep(N,K)

# Fit model:
res = mcleod(x, n, covariates = covariates)


# posterior distribution of random intercepts:
posterior_dist_gamma = mcleod.get.posterior.mixing.dist(res)

x_points = seq(-3,3,0.01)
plot(x_points, posterior_mixing_dist$density(x_points),
type = 'l',xlab = 'theta',ylab = 'Density')
}
